{"version":3,"file":"background.js","mappings":";;;;;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH,kEAAkE,oBAAoB;;AAEtF;AACA;AACA;AACA;;AAEA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,oBAAoB;AACjD;;AAEA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D,QAAQ;AACR;AACA;AACA,iCAAiC,oBAAoB;AACrD,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C,GAAG;AACH;;AAEA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD,QAAQ;AACR;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA,mCAAmC,oBAAoB;AACvD,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA,qBAAqB,mCAAmC;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,qBAAqB,6CAA6C;;AAElE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,+BAA+B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,kBAAkB,iCAAiC;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA,iCAAiC,eAAe;AAChD,uCAAuC,sCAAsC;AAC7E;AACA;;AAEA;AACA;AACA,wCAAwC,iCAAiC;AACzE,uCAAuC,sCAAsC;AAC7E;AACA;;AAEA;AACA;AACA,yCAAyC,mCAAmC;AAC5E,uCAAuC,sCAAsC;AAC7E;AACA;;AAEA;AACA,YAAY,mBAAmB;AAC/B;AACA,iCAAiC,eAAe;AAChD,uCAAuC,sCAAsC;AAC7E;AACA;;AAEA;AACA,YAAY,SAAS;AACrB;AACA,iCAAiC,eAAe;AAChD,uCAAuC,sCAAsC;AAC7E;AACA;;AAEA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;;AAEA;AACA,YAAY,+BAA+B;AAC3C;AACA;AACA;AACA,CAAC","sources":["webpack://webwise/./src/background.js"],"sourcesContent":["const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';\n\n// Send request to AI API\nasync function sendAIRequest(messages, onProgress) {\n  const settings = await getSettings();\n  const apiKey = settings.openaiApiKey;\n  const apiUrl = OPENAI_API_URL;\n  const model = settings.openaiModel || 'gpt-4o-mini';\n\n  if (!apiKey) throw new Error('API key for OpenAI is not set.');\n\n  return sendOpenAIRequest(apiUrl, apiKey, model, messages, onProgress);\n}\n\n// Get settings from storage\nfunction getSettings() {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(\n      ['openaiApiKey', 'openaiModel', 'includeContext'],\n      (result) => resolve(result)\n    );\n  });\n}\n\n// Send request to OpenAI API\nasync function sendOpenAIRequest(apiUrl, apiKey, model, messages, onProgress) {\n  const response = await fetch(apiUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${apiKey}`,\n    },\n    body: JSON.stringify({\n      model: model,\n      messages: messages,\n      stream: true,\n    }),\n  });\n\n  if (!response.ok) throw new Error(`OpenAI API request failed: ${response.statusText}`);\n\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder('utf-8');\n  let result = '';\n  let done = false;\n\n  while (!done) {\n    const { value, done: doneReading } = await reader.read();\n    done = doneReading;\n    if (value) {\n      const chunk = decoder.decode(value);\n      const lines = chunk.split('\\n').filter((line) => line.trim() !== '');\n      for (const line of lines) {\n        if (line.startsWith('data: ')) {\n          const data = line.substring(6);\n          if (data === '[DONE]') {\n            done = true;\n            break;\n          }\n          try {\n            const parsed = JSON.parse(data);\n            const content = parsed.choices[0].delta.content;\n            if (content) {\n              result += content;\n              onProgress(content, false);\n            }\n          } catch (err) {\n            console.error('Error parsing OpenAI stream data:', err);\n          }\n        }\n      }\n    }\n  }\n\n  onProgress(null, true);\n  return result;\n}\n\n// Store chat history\nfunction storeChatHistory(chatId, messages, chatTitle) {\n  chrome.storage.local.set({ [chatId]: messages }, () => {\n    console.log('Chat history stored');\n\n    chrome.storage.local.get({ chatList: [] }, (result) => {\n      const chatList = result.chatList;\n      const chatIndex = chatList.findIndex((chat) => chat.chatId === chatId);\n      if (chatIndex === -1) {\n        chatList.push({ chatId: chatId, title: chatTitle });\n      } else {\n        chatList[chatIndex].title = chatTitle;\n      }\n      chrome.storage.local.set({ chatList: chatList }, () => console.log('Chat list updated'));\n    });\n  });\n}\n\n// Retrieve chat history\nfunction getChatHistory(chatId) {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(chatId, (result) => resolve(result[chatId] || []));\n  });\n}\n\n// Retrieve chat list\nfunction getChatList() {\n  return new Promise((resolve) => {\n    chrome.storage.local.get({ chatList: [] }, (result) => resolve(result.chatList));\n  });\n}\n\n// Rename chat\nfunction renameChat(chatId, newTitle) {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.get({ chatList: [] }, (result) => {\n      const chatList = result.chatList;\n      const chatIndex = chatList.findIndex((chat) => chat.chatId === chatId);\n      if (chatIndex !== -1) {\n        chatList[chatIndex].title = newTitle;\n        chrome.storage.local.set({ chatList: chatList }, () => resolve());\n      } else {\n        reject(new Error('Chat not found'));\n      }\n    });\n  });\n}\n\n// Delete chat\nfunction deleteChat(chatId) {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.remove(chatId, () => {\n      if (chrome.runtime.lastError) {\n        reject(chrome.runtime.lastError);\n        return;\n      }\n      chrome.storage.local.get({ chatList: [] }, (result) => {\n        const chatList = result.chatList.filter((chat) => chat.chatId !== chatId);\n        chrome.storage.local.set({ chatList: chatList }, () => resolve());\n      });\n    });\n  });\n}\n\n// Continue a previous chat\nasync function continueChat(chatId, newMessage, onProgress, context) {\n  const chatHistory = await getChatHistory(chatId);\n\n  if (context) chatHistory.unshift(context);\n\n  chatHistory.push({ role: 'user', content: newMessage });\n\n  let responseContent = '';\n  await sendAIRequest(chatHistory, (partialResponse, isDone) => {\n    if (partialResponse) {\n      responseContent += partialResponse;\n      onProgress(partialResponse, false);\n    }\n    if (isDone) onProgress(null, true);\n  });\n  chatHistory.push({ role: 'assistant', content: responseContent });\n\n  let chatTitle = 'Chat';\n  if (chatHistory.length === 2 || (context && chatHistory.length === 3)) {\n    chatTitle = generateChatTitle(newMessage);\n  }\n\n  if (context) chatHistory.shift();\n\n  storeChatHistory(chatId, chatHistory, chatTitle);\n  return responseContent;\n}\n\n// Generate chat title based on first message\nfunction generateChatTitle(message) {\n  return message.length > 30 ? message.substring(0, 30) + '...' : message;\n}\n\n// Handle inline completions\nasync function handleInlineCompletion(prompt, requestId, sender) {\n  const messages = [{ role: 'user', content: prompt }];\n  const tabId = sender.tab ? sender.tab.id : null;\n  if (!tabId) {\n    chrome.tabs.sendMessage(tabId, {\n      action: 'inlineCompletionResponse',\n      requestId: requestId,\n      error: 'Tab ID not available',\n    });\n    return;\n  }\n\n  try {\n    await sendAIRequest(messages, (partialResponse, isDone) => {\n      if (partialResponse) {\n        chrome.tabs.sendMessage(tabId, {\n          action: 'inlineCompletionResponse',\n          requestId: requestId,\n          content: partialResponse,\n          isDone: false,\n        });\n      }\n      if (isDone) {\n        chrome.tabs.sendMessage(tabId, {\n          action: 'inlineCompletionResponse',\n          requestId: requestId,\n          isDone: true,\n        });\n      }\n    });\n  } catch (error) {\n    console.error('Error handling inline completion:', error);\n    chrome.tabs.sendMessage(tabId, {\n      action: 'inlineCompletionResponse',\n      requestId: requestId,\n      error: error.message,\n      isDone: true,\n    });\n  }\n}\n\n// Handle question with context\nasync function handleQuestionWithContext(question, context, requestId, sender) {\n  let messages = [];\n\n  if (context) {\n    messages.push({\n      role: 'system',\n      content: 'The following is the text selected by the user:\\n' + context,\n    });\n  }\n\n  messages.push({ role: 'user', content: question });\n\n  const tabId = sender.tab ? sender.tab.id : null;\n  if (!tabId) {\n    chrome.tabs.sendMessage(tabId, {\n      action: 'questionResponse',\n      requestId: requestId,\n      error: 'Tab ID not available',\n      isDone: true,\n    });\n    return;\n  }\n\n  try {\n    await sendAIRequest(messages, (partialResponse, isDone) => {\n      if (partialResponse) {\n        chrome.tabs.sendMessage(tabId, {\n          action: 'questionResponse',\n          requestId: requestId,\n          content: partialResponse,\n          isDone: false,\n        });\n      }\n      if (isDone) {\n        chrome.tabs.sendMessage(tabId, {\n          action: 'questionResponse',\n          requestId: requestId,\n          isDone: true,\n        });\n      }\n    });\n  } catch (error) {\n    console.error('Error handling question with context:', error);\n    chrome.tabs.sendMessage(tabId, {\n      action: 'questionResponse',\n      requestId: requestId,\n      error: error.message,\n      isDone: true,\n    });\n  }\n}\n\n// Listen for messages from content scripts or extension parts\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  if (request.action === 'continueChat') {\n    const { chatId, message, context } = request;\n    continueChat(\n      chatId,\n      message,\n      (partialResponse, isDone) => {\n        if (partialResponse) {\n          chrome.tabs.sendMessage(sender.tab.id, {\n            action: 'partialResponse',\n            chatId: chatId,\n            content: partialResponse,\n          });\n        }\n        if (isDone) {\n          chrome.tabs.sendMessage(sender.tab.id, {\n            action: 'responseComplete',\n            chatId: chatId,\n          });\n        }\n      },\n      context\n    )\n      .then(() => sendResponse({ success: true }))\n      .catch((error) => sendResponse({ success: false, error: error.message }));\n    return true;\n  }\n\n  if (request.action === 'getChatHistory') {\n    getChatHistory(request.chatId)\n      .then((history) => sendResponse({ success: true, history: history }))\n      .catch((error) => sendResponse({ success: false, error: error.message }));\n    return true;\n  }\n\n  if (request.action === 'getChatList') {\n    getChatList()\n      .then((chatList) => sendResponse({ success: true, chatList: chatList }))\n      .catch((error) => sendResponse({ success: false, error: error.message }));\n    return true;\n  }\n\n  if (request.action === 'renameChat') {\n    const { chatId, newTitle } = request;\n    renameChat(chatId, newTitle)\n      .then(() => sendResponse({ success: true }))\n      .catch((error) => sendResponse({ success: false, error: error.message }));\n    return true;\n  }\n\n  if (request.action === 'deleteChat') {\n    const { chatId } = request;\n    deleteChat(chatId)\n      .then(() => sendResponse({ success: true }))\n      .catch((error) => sendResponse({ success: false, error: error.message }));\n    return true;\n  }\n\n  if (request.action === 'inlineCompletion') {\n    const { prompt, requestId } = request;\n    handleInlineCompletion(prompt, requestId, sender);\n    return true;\n  }\n\n  if (request.action === 'askQuestionWithContext') {\n    const { question, context, requestId } = request;\n    handleQuestionWithContext(question, context, requestId, sender);\n    return true;\n  }\n});\n"],"names":[],"sourceRoot":""}